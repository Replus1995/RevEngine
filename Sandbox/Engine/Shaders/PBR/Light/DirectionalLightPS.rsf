#kind pixel
#version 450 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_KHR_vulkan_glsl : enable
#extension GL_GOOGLE_include_directive : enable

#include "/Engine/Shaders/Global.rsh"
#include "/Engine/Shaders/PBR/GlobalPBR.rsh"

layout(location = 5) uniform sampler2D s_ColorTex;
layout(location = 6) uniform sampler2D s_NormalTex;
layout(location = 7) uniform sampler2D s_MROTex;
layout(location = 8) uniform sampler2D s_DepthStencilTex;
layout(location = 9) uniform sampler2D s_ShadowTex;

uniform vec3 cameraPos;

uniform vec3 lightDir;
uniform vec4 lightColour;
uniform float lightStrength;

uniform mat4 inverseProjView;
uniform mat4 shadowMatrix;

in Vertex
{
    vec2 TexCoord0;
} IN;

layout(location = 0) out vec4 o_Diffuse;
layout(location = 1) out vec4 o_Specular;



void main(void)
{
    vec2 texCoord = IN.TexCoord0;
    float depth = texture(depthTex, texCoord).r;
    vec3 ndcPos = vec3(texCoord, depth) * 2.0 - 1.0;
    vec4 invClipPos = inverseProjView * vec4(ndcPos, 1.0);
    vec3 worldPos = invClipPos.xyz / invClipPos.w;

    //vec3 color = pow(texture(colourTex, texCoord).rgb, vec3(2.2));
    vec3 color = texture(colourTex, texCoord).rgb;
    vec3 normal = normalize(texture(normTex, texCoord).xyz * 2.0 - 1.0);
    vec3 incident = normalize(lightDir * -1.0f);
    vec3 viewDir = normalize(cameraPos - worldPos);
    vec3 halfDir = normalize(incident + viewDir);

    vec3 mroColour = texture(metallicRoughnessTex, texCoord).rgb;
    float metallic = mroColour.r;
    float roughness = mroColour.g;
    float occlution = mroColour.b;

    vec3 reflective = vec3(0.04); 
    reflective = mix(reflective, colour, metallic);
    vec3 F = Schlick_F(reflective, max(dot(halfDir, viewDir), 0));
    float D = GGX_D(normal, halfDir, roughness);
    float G = GGX_G(normal, viewDir, roughness) * GGX_G(normal, incident, roughness);

    vec3 diffuse = (vec3(1.0) - F) * (1.0 - metallic) / PI;
    float nl = dot(normal, incident);
    float nv = dot(normal, viewDir);
    vec3 specular = (F * D * G) / (4 * nl * nv);
    
    vec3 pushVal = normal;
    vec4 shadowProj = shadowMatrix * vec4((worldPos + pushVal), 1.0f);

    float shadow = 1.0;
    vec3 shadowNDC = shadowProj.xyz / shadowProj.w;
    if( abs(shadowNDC.x) < 1.0f &&
        abs(shadowNDC.y) < 1.0f &&
        abs(shadowNDC.z) < 1.0f)
    {
        vec3 biasCoord = shadowNDC * 0.5f + 0.5f;
        float shadowZ = texture(shadowTex, biasCoord.xy).x;
        if(shadowZ < biasCoord.z)
        {
            shadow = 0.0f;
        }
    }

    vec3 radiance = lightColour.xyz * lightStrength * 2;

    o_Diffuse.rgb = diffuse * radiance * nl * shadow;
    o_Diffuse.a = occlution;

    o_Specular.rgb = specular * radiance * nl * shadow;
    o_Specular.a = 1.0;

}