#version 450 core
#pragma shader_stage(fragment)
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "/Engine/Shaders/Light.rsh"
#include "/Engine/Shaders/PBR/GlobalPBR.rsh"

layout(location = 5) uniform vec4 u_BaseColorFactor;
layout(location = 6) uniform float u_Metallic;
layout(location = 7) uniform float u_Roughness;
layout(location = 8) uniform float u_NormalScale;
layout(location = 9) uniform float u_OcclusionStrength;
layout(location = 10) uniform vec3 u_EmissiveFactor;

layout(location = 11) uniform sampler2D s_BaseColorTex;
layout(location = 12) uniform sampler2D s_MetallicRoughnessTex;
layout(location = 13) uniform sampler2D s_NormalTex;
layout(location = 14) uniform sampler2D s_OcclusionTex;
layout(location = 15) uniform sampler2D s_EmissiveTex;

layout(location = 0) in Vertex
{
    vec3 WorldPos;
    vec3 Normal;
    vec3 Tangent;
    vec3 Bitangent;
    vec4 Color;
    vec2 TexCoord0;
} IN;

layout(location = 0) out vec4 o_Color;

void main(void)
{
    //Color
    vec4 BaseColor = texture(s_BaseColorTex, IN.TexCoord0);
    //BaseColor.rgb = pow(BaseColor.rgb, vec3(2.2)); //ToLinear
    BaseColor *= u_BaseColorFactor;

    //Normal

    mat3 TBN = mat3(IN.Tangent, IN.Bitangent, IN.Normal);
    vec3 TexNormal = normalize((texture(s_NormalTex, IN.TexCoord0).xyz * 2.0 - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0f));
    vec3 Normal = normalize(TBN * TexNormal);
    //vec3 Normal = IN.Normal;

    //MetallicRoughness
    float Metallic = u_Metallic * texture(s_MetallicRoughnessTex, IN.TexCoord0).r;
    float Roughness = u_Roughness * texture(s_MetallicRoughnessTex, IN.TexCoord0).g;
    //Occlusion
    float Occlution = u_OcclusionStrength * texture(s_OcclusionTex, IN.TexCoord0).r;
    //Emissive
    vec3 Emissive = texture(s_EmissiveTex, IN.TexCoord0).rgb * u_EmissiveFactor;

    vec3 ViewDir = normalize(ub_Camera.Pos.xyz - IN.WorldPos);
    float NdV = max(dot(Normal, ViewDir), 0.0);
    vec3 F0 = mix(kDielectric, BaseColor.rgb, Metallic);

    vec3 LightColor = vec3(0.0);
    for(uint i = 0; i < ub_ForwardLight.LightCount; i++)
    {
        vec4 res = PreComputeLight(IN.WorldPos, ub_ForwardLight.Lights[i]);
        vec3 LightDir = res.xyz;
        float Radiance = res.w;
        if(Radiance == 0.0)
        {
            continue;
        }

        vec3 HalfDir = normalize(LightDir + ViewDir);
        float NdL = max(dot(Normal, LightDir), 0.0);
        float NdH = max(dot(Normal, HalfDir), 0.0);
        float HdV = max(dot(HalfDir, ViewDir), 0.0);

        vec3 F = F_Schlick(F0, HdV);
		float D = D_GGX(Roughness, NdH);
        float G = G_SchlickGGX(Roughness, NdV, NdL);

        vec3 kd = mix(vec3(1.0) - F, vec3(0.0), Metallic);
        vec3 diffuseBRDF = kd * BaseColor.rgb;
        vec3 specularBRDF = (F * D * G) / max(EPSILON, 4.0 * NdL * NdV);

        //TODO: Shadow

        LightColor += (diffuseBRDF + specularBRDF) * Radiance * NdL;
    }

    //TODO: IBL Lighting

    vec3 Ambient = kAmbientFactor * BaseColor.rgb * Occlution;

    o_Color.rgb = Ambient + LightColor + Emissive;
    o_Color.rgb = pow(o_Color.rgb, vec3(1.0/2.2)); //Gamma Correction
    o_Color.a = BaseColor.a;
}